var It = Object.defineProperty;
var Tt = (r, t, e) => t in r ? It(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var o = (r, t, e) => (Tt(r, typeof t != "symbol" ? t + "" : t, e), e);
class ht {
  constructor(t, e) {
    this.prefix = t, this.enabled = e;
  }
  /**
   * Prints message into a console in case, logger is currently enabled.
   * @param level - log level.
   * @param args - arguments.
   */
  print(t, ...e) {
    if (!this.enabled)
      return;
    const s = /* @__PURE__ */ new Date(), n = Intl.DateTimeFormat("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      fractionalSecondDigits: 3,
      timeZone: "UTC"
    }).format(s);
    console[t](`[${n}]`, this.prefix, ...e);
  }
  /**
   * Disables the logger.
   */
  disable() {
    this.enabled = !1;
  }
  /**
   * Prints error message into a console.
   * @param args
   */
  error(...t) {
    this.print("error", ...t);
  }
  /**
   * Enables the logger.
   */
  enable() {
    this.enabled = !0;
  }
  /**
   * Prints log message into a console.
   * @param args
   */
  log(...t) {
    this.print("log", ...t);
  }
  /**
   * Prints warning message into a console.
   * @param args
   */
  warn(...t) {
    this.print("warn", ...t);
  }
}
let ut = "https://web.telegram.org";
const k = new ht("[SDK]", !1);
function Qe(r) {
  if (r) {
    k.enable();
    return;
  }
  k.disable();
}
function Ze(r) {
  ut = r;
}
function $t() {
  return ut;
}
function pt() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
function W(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r);
}
function Lt(r) {
  return "external" in r && W(r.external) && "notify" in r.external && typeof r.external.notify == "function";
}
function Bt(r) {
  return "TelegramWebviewProxy" in r && W(r.TelegramWebviewProxy) && "postEvent" in r.TelegramWebviewProxy && typeof r.TelegramWebviewProxy.postEvent == "function";
}
function d(r, t, e) {
  let s = {}, n;
  t === void 0 && e === void 0 ? s = {} : t !== void 0 && e !== void 0 ? (s = e, n = t) : t !== void 0 && ("targetOrigin" in t ? s = t : n = t);
  const { targetOrigin: i = $t() } = s;
  if (k.log(`Calling method "${r}"`, n), pt()) {
    window.parent.postMessage(JSON.stringify({
      eventType: r,
      eventData: n
    }), i);
    return;
  }
  if (Lt(window)) {
    window.external.notify(JSON.stringify({ eventType: r, eventData: n }));
    return;
  }
  if (Bt(window)) {
    window.TelegramWebviewProxy.postEvent(r, JSON.stringify(n));
    return;
  }
  throw new Error(
    "Unable to determine current environment and possible way to send event."
  );
}
function Dt(r, t) {
  const e = r.split("."), s = t.split("."), n = Math.max(e.length, s.length);
  for (let i = 0; i < n; i += 1) {
    const a = parseInt(e[i] || "0", 10), c = parseInt(s[i] || "0", 10);
    if (a !== c)
      return a > c ? 1 : -1;
  }
  return 0;
}
function v(r, t) {
  return Dt(r, t) <= 0;
}
function A(r, t, e) {
  if (typeof e == "string") {
    if (r === "web_app_open_link" && t === "try_instant_view")
      return v("6.4", e);
    if (r === "web_app_set_header_color" && t === "color")
      return v("6.9", e);
  }
  switch (r) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return v("6.1", t);
    case "web_app_open_popup":
      return v("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return v("6.4", t);
    case "web_app_switch_inline_query":
      return v("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return v("6.9", t);
    case "web_app_setup_settings_button":
      return v("6.10", t);
    default:
      return !0;
  }
}
class K extends Error {
  constructor(t, e) {
    super(`Method "${t}" is unsupported in the Mini Apps version ${e}.`), Object.setPrototypeOf(this, K.prototype);
  }
}
class Y extends Error {
  constructor(t, e, s) {
    super(`Parameter "${e}" in method "${t}" is unsupported in the Mini Apps version ${s}.`), Object.setPrototypeOf(this, Y.prototype);
  }
}
function Ot(r) {
  return (t, e) => {
    if (!A(t, r))
      throw new K(t, r);
    if (W(e)) {
      let s;
      if (t === "web_app_open_link" && "try_instant_view" in e ? s = "try_instant_view" : t === "web_app_set_header_color" && "color" in e && (s = "color"), s && !A(t, s, r))
        throw new Y(t, s, r);
    }
    return d(t, e);
  };
}
function lt(r) {
  return ({ req_id: t }) => t === r;
}
class j extends Error {
  constructor(e, { cause: s, type: n } = {}) {
    super(`Unable to parse value${n ? ` as ${n}` : ""}`, { cause: s });
    /**
     * Parser name.
     */
    o(this, "type");
    this.value = e, Object.setPrototypeOf(this, j.prototype), this.type = n;
  }
}
class G extends Error {
  constructor(t, { cause: e, type: s } = {}) {
    super(`Unable to parse field "${t}"${s ? ` as ${s}` : ""}`, { cause: e }), Object.setPrototypeOf(this, G.prototype);
  }
}
function dt(r, t) {
  const e = {};
  for (const s in r) {
    const n = r[s];
    if (!n)
      continue;
    let i, a;
    if (typeof n == "function" || "parse" in n)
      i = s, a = typeof n == "function" ? n : n.parse.bind(n);
    else {
      const { type: p } = n;
      i = n.from || s, a = typeof p == "function" ? p : p.parse.bind(p);
    }
    let c;
    const u = t(i);
    try {
      c = a(u);
    } catch (p) {
      throw p instanceof j ? new G(i, {
        type: p.type,
        cause: p
      }) : new G(i, { cause: p });
    }
    c !== void 0 && (e[s] = c);
  }
  return e;
}
function V() {
  return new TypeError("Value has unexpected type");
}
function X(r) {
  let t = r;
  if (typeof t == "string" && (t = JSON.parse(t)), typeof t != "object" || t === null || Array.isArray(t))
    throw V();
  return t;
}
class F {
  constructor(t, e, s) {
    this.parser = t, this.isOptional = e, this.type = s;
  }
  parse(t) {
    if (!(this.isOptional && t === void 0))
      try {
        return this.parser(t);
      } catch (e) {
        throw new j(t, { type: this.type, cause: e });
      }
  }
  optional() {
    return this.isOptional = !0, this;
  }
}
function f(r, t) {
  return new F((e) => {
    const s = X(e);
    return dt(r, (n) => s[n]);
  }, !1, t);
}
function R(r, t) {
  return () => new F(r, !1, t);
}
const h = R((r) => {
  if (typeof r == "string" || typeof r == "number")
    return r.toString();
  throw V();
}, "string");
function Wt(r) {
  return f({
    eventType: h(),
    eventData: (t) => t
  }).parse(r);
}
function Ht(r, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: r, eventData: t }),
    // We specify window.parent to imitate the case, it sent us this event.
    source: window.parent
  }));
}
function Nt() {
  const r = window;
  "TelegramGameProxy_receiveEvent" in r || [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((t) => {
    let e = r;
    t.forEach((s, n, i) => {
      if (n === i.length - 1) {
        e[s] = Ht;
        return;
      }
      s in e || (e[s] = {}), e = e[s];
    });
  });
}
function Ut(r) {
  Nt(), window.addEventListener("message", (t) => {
    if (t.source === window.parent)
      try {
        const { eventType: e, eventData: s } = Wt(t.data);
        r(e, s);
      } catch {
      }
  });
}
function Mt() {
  return f({
    req_id: h(),
    data: (r) => r === null ? r : h().optional().parse(r)
  });
}
function Gt() {
  return f({
    req_id: h(),
    result: (r) => r,
    error: h().optional()
  });
}
function jt() {
  return f({
    slug: h(),
    status: h()
  });
}
function Ft() {
  return f({ status: h() });
}
function zt() {
  return f({
    button_id: (r) => r == null ? void 0 : h().parse(r)
  });
}
function Jt() {
  return f({
    data: h().optional()
  });
}
function tt(r) {
  return /^#[\da-f]{6}$/i.test(r);
}
function Qt(r) {
  return /^#[\da-f]{3}$/i.test(r);
}
function ft(r) {
  const t = r.replace(/\s/g, "").toLowerCase();
  if (tt(t))
    return t;
  if (Qt(t)) {
    let s = "#";
    for (let n = 0; n < 3; n += 1)
      s += t[1 + n].repeat(2);
    return s;
  }
  const e = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (e === null)
    throw new Error(`Value "${r}" does not satisfy any of known RGB formats.`);
  return e.slice(1).reduce((s, n) => {
    const i = parseInt(n, 10).toString(16);
    return s + (i.length === 1 ? "0" : "") + i;
  }, "#");
}
const gt = R((r) => ft(h().parse(r)), "rgb");
function Zt() {
  return f({
    theme_params: (r) => {
      const t = gt().optional();
      return Object.entries(X(r)).reduce((e, [s, n]) => (e[s] = t.parse(n), e), {});
    }
  });
}
const P = R((r) => {
  if (typeof r == "boolean")
    return r;
  const t = String(r);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  throw V();
}, "boolean"), x = R((r) => {
  if (typeof r == "number")
    return r;
  if (typeof r == "string") {
    const t = Number(r);
    if (!Number.isNaN(t))
      return t;
  }
  throw V();
}, "number");
function Kt() {
  return f({
    height: x(),
    width: (r) => r == null ? window.innerWidth : x().parse(r),
    is_state_stable: P(),
    is_expanded: P()
  });
}
function Yt() {
  return f({ status: h() });
}
class w {
  constructor() {
    o(this, "listeners", /* @__PURE__ */ new Map());
    o(this, "subscribeListeners", []);
  }
  /**
   * Adds specified event listener.
   * @param event - event name.
   * @param listener - event listener.
   * @param once - should listener called only once.
   */
  addListener(t, e, s) {
    let n = this.listeners.get(t);
    return n || (n = [], this.listeners.set(t, n)), n.push([e, s]), () => this.off(t, e);
  }
  emit(t, ...e) {
    this.subscribeListeners.forEach((n) => n(t, ...e));
    const s = this.listeners.get(t);
    s && s.forEach(([n, i], a) => {
      n(...e), i && s.splice(a, 1);
    });
  }
  /**
   * Adds event listener.
   * @param event - event name.
   * @param listener - event listener.
   * @returns Function to remove event listener.
   */
  on(t, e) {
    return this.addListener(t, e, !1);
  }
  /**
   * Adds event listener following the logic, described in `on` method, but calls specified
   * listener only once, removing it after.
   * @param event - event name.
   * @param listener - event listener.
   * @returns Function to remove event listener.
   * @see on
   */
  once(t, e) {
    return this.addListener(t, e, !0);
  }
  /**
   * Removes event listener. In case, specified listener was bound several times, it removes
   * only a single one.
   * @param event - event name.
   * @param listener - event listener.
   */
  off(t, e) {
    const s = this.listeners.get(t);
    if (s) {
      for (let n = 0; n < s.length; n += 1)
        if (e === s[n][0]) {
          s.splice(n, 1);
          return;
        }
    }
  }
  /**
   * Adds event listener to all events.
   * @param listener - events listener.
   * @returns Function to remove event listener.
   * @see on
   * @see once
   */
  subscribe(t) {
    return this.subscribeListeners.push(t), () => this.unsubscribe(t);
  }
  /**
   * Removes global event listener. In case, specified listener was bound several times, it removes
   * only a single one.
   * @param listener - events listener.
   * @returns Function to remove event listener.
   */
  unsubscribe(t) {
    for (let e = 0; e < this.subscribeListeners.length; e += 1)
      if (this.subscribeListeners[e] === t) {
        this.subscribeListeners.splice(e, 1);
        return;
      }
  }
}
function Xt() {
  const r = new w(), t = (e, ...s) => {
    k.log("Emitting processed event:", e, ...s), r.emit(e, ...s);
  };
  return window.addEventListener("resize", () => {
    t("viewport_changed", {
      width: window.innerWidth,
      height: window.innerHeight,
      is_state_stable: !0,
      is_expanded: !0
    });
  }), Ut((e, s) => {
    k.log("Received raw event:", e, s);
    try {
      switch (e) {
        case "viewport_changed":
          return t(e, Kt().parse(s));
        case "theme_changed":
          return t(e, Zt().parse(s));
        case "popup_closed":
          return (
            // Sent on desktop.
            s == null ? t(e, {}) : t(e, zt().parse(s))
          );
        case "set_custom_style":
          return t(e, h().parse(s));
        case "qr_text_received":
          return t(e, Jt().parse(s));
        case "clipboard_text_received":
          return t(e, Mt().parse(s));
        case "invoice_closed":
          return t(e, jt().parse(s));
        case "phone_requested":
          return t("phone_requested", Ft().parse(s));
        case "custom_method_invoked":
          return t("custom_method_invoked", Gt().parse(s));
        case "write_access_requested":
          return t("write_access_requested", Yt().parse(s));
        case "main_button_pressed":
        case "back_button_pressed":
        case "settings_button_pressed":
        case "scan_qr_popup_closed":
        case "reload_iframe":
          return t(e);
        default:
          return t(e, s);
      }
    } catch (n) {
      k.error("Error processing event:", n);
    }
  }), r;
}
const J = "telegram-mini-apps-cached-emitter";
function H() {
  const r = window;
  return r[J] === void 0 && (r[J] = Xt()), r[J];
}
function I(r, t) {
  H().off(r, t);
}
function E(r, t) {
  return H().on(r, t), () => I(r, t);
}
class z extends Error {
  constructor(t) {
    super(`Async call timeout exceeded. Timeout: ${t}`), Object.setPrototypeOf(this, z.prototype);
  }
}
function te(r) {
  return new Promise((t, e) => {
    setTimeout(e, r, new z(r));
  });
}
function wt(r, t) {
  return Promise.race([
    typeof r == "function" ? r() : r,
    te(t)
  ]);
}
async function y(r, t, e) {
  let s;
  const n = new Promise((b) => {
    s = b;
  }), i = t ? {
    ...e,
    event: t,
    method: r
  } : r, {
    method: a,
    event: c,
    capture: u,
    postEvent: p = d,
    timeout: g
  } = i, _ = (Array.isArray(c) ? c : [c]).map(
    (b) => E(b, (l) => (!u || u(l)) && s(l))
  );
  try {
    return p(a, i.params), await (g ? wt(n, g) : n);
  } finally {
    _.forEach((b) => b());
  }
}
async function D(r, t, e, s = {}) {
  const {
    result: n,
    error: i
  } = await y("web_app_invoke_custom_method", "custom_method_invoked", {
    ...s,
    params: {
      method: r,
      params: t,
      req_id: e
    },
    capture: lt(e)
  });
  if (i)
    throw new Error(i);
  return n;
}
function Ke(r, t) {
  return H().once(r, t), () => I(r, t);
}
function ee(r) {
  H().unsubscribe(r);
}
function Ye(r) {
  return H().subscribe(r), () => ee(r);
}
function U(r, t) {
  return r + (r.length && t.length ? ` ${t}` : t);
}
function _t(...r) {
  return r.reduce((t, e) => typeof e == "string" ? U(t, e) : W(e) ? U(t, Object.entries(e).reduce((s, n) => n[1] ? U(s, n[0]) : s, "")) : Array.isArray(e) ? U(t, _t(...e)) : t, "");
}
function Xe(...r) {
  return r.reduce((t, e) => (W(e) && Object.entries(e).forEach(([s, n]) => {
    const i = _t(t[s], n);
    i.length > 0 && (t[s] = i);
  }), t), {});
}
function bt(r) {
  const t = ft(r);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((s, n, i) => {
      const a = parseInt(t.slice(1 + i * 2, 1 + (i + 1) * 2), 16);
      return s + a * a * n;
    }, 0)
  ) < 120;
}
class m {
  constructor(t, e) {
    this.state = t, this.ee = e;
  }
  internalSet(t, e) {
    return this.state[t] === e || e === void 0 ? !1 : (this.state[t] = e, this.ee.emit(`change:${t}`, e), !0);
  }
  /**
   * Returns copy of current state.
   */
  clone() {
    return { ...this.state };
  }
  set(t, e) {
    let s = !1;
    if (typeof t == "string")
      s = this.internalSet(t, e);
    else
      for (const n in t)
        this.internalSet(n, t[n]) && (s = !0);
    s && this.ee.emit("change");
  }
  /**
   * Returns value by specified key.
   * @param key - state key.
   */
  get(t) {
    return this.state[t];
  }
}
function C(r, t) {
  return (e) => A(t[e], r);
}
class re {
  constructor(t, e, s = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "on", (t, e) => t === "click" ? E("back_button_pressed", e) : this.ee.on(t, e));
    /**
     * Removes event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "off", (t, e) => t === "click" ? I("back_button_pressed", e) : this.ee.off(t, e));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = s, this.state = new m({ isVisible: t }, this.ee), this.supports = C(e, {
      show: "web_app_setup_back_button",
      hide: "web_app_setup_back_button"
    });
  }
  set isVisible(t) {
    this.state.set("isVisible", t), this.postEvent("web_app_setup_back_button", { is_visible: t });
  }
  /**
   * True if BackButton is currently visible.
   */
  get isVisible() {
    return this.state.get("isVisible");
  }
  /**
   * Hides the BackButton.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Shows the BackButton.
   */
  show() {
    this.isVisible = !0;
  }
}
class se {
  constructor(t, e = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    this.postEvent = e, this.state = new m({ isConfirmationNeeded: t }, this.ee);
  }
  set isConfirmationNeeded(t) {
    this.state.set("isConfirmationNeeded", t), this.postEvent("web_app_setup_closing_behavior", { need_confirmation: t });
  }
  /**
   * Returns true, if the confirmation dialog enabled while the user is trying
   * to close the Mini App.
   */
  get isConfirmationNeeded() {
    return this.state.get("isConfirmationNeeded");
  }
  /**
   * Disables the confirmation dialog while the user is trying to close the
   * Mini App.
   */
  disableConfirmation() {
    this.isConfirmationNeeded = !1;
  }
  /**
   * Enables the confirmation dialog while the user is trying to close the
   * Mini App.
   */
  enableConfirmation() {
    this.isConfirmationNeeded = !0;
  }
}
function ne(r) {
  if (Array.isArray(r))
    return r;
  if (typeof r == "string")
    try {
      const t = JSON.parse(r);
      if (Array.isArray(t))
        return t;
    } catch {
    }
  throw V();
}
class ie extends F {
  constructor(e, s, n) {
    super(ne, s, n);
    o(this, "itemParser");
    this.itemParser = typeof e == "function" ? e : e.parse.bind(e);
  }
  parse(e) {
    const s = super.parse(e);
    return s === void 0 ? s : s.map(this.itemParser);
  }
  of(e) {
    return this.itemParser = typeof e == "function" ? e : e.parse.bind(e), this;
  }
}
function oe(r) {
  return new ie((t) => t, !1, r);
}
function nt(r, t) {
  return r.reduce((e, s) => (e[s] = t, e), {});
}
class ae {
  constructor(t, e, s = d) {
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.createRequestId = e, this.postEvent = s, this.supports = C(t, {
      delete: "web_app_invoke_custom_method",
      get: "web_app_invoke_custom_method",
      getKeys: "web_app_invoke_custom_method",
      set: "web_app_invoke_custom_method"
    });
  }
  /**
   * Deletes specified key or keys from the cloud storage.
   * @param keyOrKeys - key or keys to delete.
   * @param options - request execution options.
   */
  async delete(t, e = {}) {
    const s = Array.isArray(t) ? t : [t];
    s.length !== 0 && await D(
      "deleteStorageValues",
      { keys: s },
      this.createRequestId(),
      { ...e, postEvent: this.postEvent }
    );
  }
  /**
   * Returns list of all keys presented in the cloud storage.
   * @param options - request execution options.
   */
  async getKeys(t = {}) {
    const e = await D(
      "getStorageKeys",
      {},
      this.createRequestId(),
      { ...t, postEvent: this.postEvent }
    );
    return oe().of(h()).parse(e);
  }
  async get(t, e = {}) {
    const s = Array.isArray(t) ? t : [t];
    if (s.length === 0)
      return nt(s, "");
    const n = f(
      nt(s, h())
    ), i = await D(
      "getStorageValues",
      { keys: s },
      this.createRequestId(),
      { ...e, postEvent: this.postEvent }
    ).then((a) => n.parse(a));
    return Array.isArray(t) ? i : i[t];
  }
  /**
   * Saves specified value by key.
   * @param key - storage key.
   * @param value - storage value.
   * @param options - request execution options.
   */
  async set(t, e, s = {}) {
    await D(
      "saveStorageValue",
      { key: t, value: e },
      this.createRequestId(),
      { ...s, postEvent: this.postEvent }
    );
  }
}
class ce {
  constructor(t, e = d) {
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = e, this.supports = C(t, {
      impactOccurred: "web_app_trigger_haptic_feedback",
      notificationOccurred: "web_app_trigger_haptic_feedback",
      selectionChanged: "web_app_trigger_haptic_feedback"
    });
  }
  /**
   * A method tells that an impact occurred. The Telegram app may play the
   * appropriate haptics based on style value passed.
   * @param style - impact style.
   */
  impactOccurred(t) {
    this.postEvent("web_app_trigger_haptic_feedback", {
      type: "impact",
      impact_style: t
    });
  }
  /**
   * A method tells that a task or action has succeeded, failed, or produced
   * a warning. The Telegram app may play the appropriate haptics based on
   * type value passed.
   * @param type - notification type.
   */
  notificationOccurred(t) {
    this.postEvent("web_app_trigger_haptic_feedback", {
      type: "notification",
      notification_type: t
    });
  }
  /**
   * A method tells that the user has changed a selection. The Telegram app
   * may play the appropriate haptics.
   *
   * Do not use this feedback when the user makes or confirms a selection;
   * use it only when the selection changes.
   */
  selectionChanged() {
    this.postEvent("web_app_trigger_haptic_feedback", { type: "selection_change" });
  }
}
function he() {
  return f({
    id: x(),
    type: h(),
    title: h(),
    photoUrl: {
      type: h().optional(),
      from: "photo_url"
    },
    username: h().optional()
  }, "Chat");
}
class ue {
  constructor(t) {
    this.initData = t;
  }
  /**
   * @see InitDataParsed.authDate
   */
  get authDate() {
    return this.initData.authDate;
  }
  /**
   * @see InitDataParsed.canSendAfter
   */
  get canSendAfter() {
    return this.initData.canSendAfter;
  }
  /**
   * Date after which it is allowed to call
   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.
   */
  get canSendAfterDate() {
    const { canSendAfter: t } = this;
    return t === void 0 ? void 0 : new Date(this.authDate.getTime() + t * 1e3);
  }
  /**
   * @see InitDataParsed.chat
   */
  get chat() {
    return this.initData.chat;
  }
  /**
   * @see InitDataParsed.chatType
   */
  get chatType() {
    return this.initData.chatType;
  }
  /**
   * @see InitDataParsed.chatInstance
   */
  get chatInstance() {
    return this.initData.chatInstance;
  }
  /**
   * @see InitDataParsed.hash
   */
  get hash() {
    return this.initData.hash;
  }
  /**
   * @see InitDataParsed.queryId
   */
  get queryId() {
    return this.initData.queryId;
  }
  /**
   * @see InitDataParsed.receiver
   */
  get receiver() {
    return this.initData.receiver;
  }
  /**
   * @see InitDataParsed.startParam
   */
  get startParam() {
    return this.initData.startParam;
  }
  /**
   * @see InitDataParsed.user
   */
  get user() {
    return this.initData.user;
  }
}
function it() {
  return f({
    addedToAttachmentMenu: {
      type: P().optional(),
      from: "added_to_attachment_menu"
    },
    allowsWriteToPm: {
      type: P().optional(),
      from: "allows_write_to_pm"
    },
    firstName: {
      type: h(),
      from: "first_name"
    },
    id: x(),
    isBot: {
      type: P().optional(),
      from: "is_bot"
    },
    isPremium: {
      type: P().optional(),
      from: "is_premium"
    },
    languageCode: {
      type: h().optional(),
      from: "language_code"
    },
    lastName: {
      type: h().optional(),
      from: "last_name"
    },
    photoUrl: {
      type: h().optional(),
      from: "photo_url"
    },
    username: h().optional()
  }, "User");
}
const mt = R((r) => r instanceof Date ? r : new Date(x().parse(r) * 1e3), "Date");
function et(r, t) {
  return new F((e) => {
    if (typeof e != "string" && !(e instanceof URLSearchParams))
      throw V();
    const s = typeof e == "string" ? new URLSearchParams(e) : e;
    return dt(r, (n) => {
      const i = s.get(n);
      return i === null ? void 0 : i;
    });
  }, !1, t);
}
function yt() {
  return et({
    authDate: {
      type: mt(),
      from: "auth_date"
    },
    canSendAfter: {
      type: x().optional(),
      from: "can_send_after"
    },
    chat: he().optional(),
    chatInstance: {
      type: h().optional(),
      from: "chat_instance"
    },
    chatType: {
      type: h().optional(),
      from: "chat_type"
    },
    hash: h(),
    queryId: {
      type: h().optional(),
      from: "query_id"
    },
    receiver: it().optional(),
    startParam: {
      type: h().optional(),
      from: "start_param"
    },
    user: it().optional()
  }, "InitData");
}
function tr(r) {
  return yt().parse(r);
}
function pe(r) {
  const { hostname: t, pathname: e } = new URL(r, window.location.href);
  if (t !== "t.me")
    throw new Error(`Incorrect hostname: ${t}`);
  const s = e.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
  if (s === null)
    throw new Error('Link pathname has incorrect format. Expected to receive "/invoice/{slug}" or "/${slug}"');
  return s[2];
}
class le {
  constructor(t, e = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = e, this.state = new m({ isOpened: !1 }, this.ee), this.supports = C(t, { open: "web_app_open_invoice" });
  }
  set isOpened(t) {
    this.state.set("isOpened", t);
  }
  /**
   * True if invoice is currently opened.
   */
  get isOpened() {
    return this.state.get("isOpened");
  }
  async open(t, e) {
    if (this.isOpened)
      throw new Error("Invoice is already opened");
    const s = e ? pe(t) : t;
    this.isOpened = !0;
    try {
      return (await y("web_app_open_invoice", "invoice_closed", {
        params: { slug: s },
        postEvent: this.postEvent,
        capture(i) {
          return s === i.slug;
        }
      })).status;
    } finally {
      this.isOpened = !1;
    }
  }
}
class de {
  constructor(t) {
    o(this, "ee", new w());
    o(this, "state");
    o(this, "postEvent");
    /**
     * Adds new event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "on", (t, e) => (
      // FIXME: Event 'main_button_pressed' is still being received on Android
      //  even if the main button is disabled.
      //  Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/3
      t === "click" ? E("main_button_pressed", e) : this.ee.on(t, e)
    ));
    /**
     * Removes event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "off", (t, e) => t === "click" ? I("main_button_pressed", e) : this.ee.off(t, e));
    const {
      postEvent: e = d,
      text: s,
      textColor: n,
      backgroundColor: i,
      isEnabled: a,
      isVisible: c,
      isLoaderVisible: u
    } = t;
    this.postEvent = e, this.state = new m({
      backgroundColor: i,
      isEnabled: a,
      isVisible: c,
      isLoaderVisible: u,
      text: s,
      textColor: n
    }, this.ee);
  }
  /**
   * Sends current local state to Telegram application.
   */
  commit() {
    this.text !== "" && this.postEvent("web_app_setup_main_button", {
      is_visible: this.isVisible,
      is_active: this.isEnabled,
      is_progress_visible: this.isLoaderVisible,
      text: this.text,
      color: this.backgroundColor,
      text_color: this.textColor
    });
  }
  set isEnabled(t) {
    this.setParams({ isEnabled: t });
  }
  /**
   * True if the Main Button is currently enabled.
   */
  get isEnabled() {
    return this.state.get("isEnabled");
  }
  set isLoaderVisible(t) {
    this.setParams({ isLoaderVisible: t });
  }
  /**
   * True if the Main Button loader is currently visible.
   */
  get isLoaderVisible() {
    return this.state.get("isLoaderVisible");
  }
  set isVisible(t) {
    this.setParams({ isVisible: t });
  }
  /**
   * True if the Main Button is currently visible.
   */
  get isVisible() {
    return this.state.get("isVisible");
  }
  /**
   * The Main Button background color.
   */
  get backgroundColor() {
    return this.state.get("backgroundColor");
  }
  /**
   * The Main Button text.
   */
  get text() {
    return this.state.get("text");
  }
  /**
   * The Main Button text color.
   */
  get textColor() {
    return this.state.get("textColor");
  }
  /**
   * Disables the Main Button.
   */
  disable() {
    return this.isEnabled = !1, this;
  }
  /**
   * Enables the Main Button.
   */
  enable() {
    return this.isEnabled = !0, this;
  }
  /**
   * Hides the Main Button.
   */
  hide() {
    return this.isVisible = !1, this;
  }
  /**
   * Hides the Main Button loader.
   */
  hideLoader() {
    return this.isLoaderVisible = !1, this;
  }
  /**
   * Shows the Main Button. Note that opening the Mini App from the attachment menu hides the
   * main button until the user interacts with the Mini App interface.
   */
  show() {
    return this.isVisible = !0, this;
  }
  /**
   * A method to show a loading indicator on the Main Button. It is recommended to display
   * loader if the action tied to the button may take a long time.
   */
  showLoader() {
    return this.isLoaderVisible = !0, this;
  }
  /**
   * Sets new Main Button text. Minimal length for text is 1 symbol, and maximum is 64 symbols.
   * @param text - new text.
   */
  setText(t) {
    return this.setParams({ text: t });
  }
  /**
   * Sets new Main Button text color.
   * @param textColor - new text color.
   */
  setTextColor(t) {
    return this.setParams({ textColor: t });
  }
  /**
   * Updates current Main Button color.
   * @param backgroundColor - color to set.
   */
  setBackgroundColor(t) {
    return this.setParams({ backgroundColor: t });
  }
  /**
   * Allows setting multiple Main Button parameters.
   * @param params - Main Button parameters.
   */
  setParams(t) {
    return this.state.set(t), this.commit(), this;
  }
}
const fe = et({
  contact: f({
    userId: {
      type: x(),
      from: "user_id"
    },
    phoneNumber: {
      type: h(),
      from: "phone_number"
    },
    firstName: {
      type: h(),
      from: "first_name"
    },
    lastName: {
      type: h().optional(),
      from: "last_name"
    }
  }),
  authDate: {
    type: mt(),
    from: "auth_date"
  },
  hash: h()
});
function Et(r, t) {
  return (e) => {
    const [s, n] = t[e];
    return A(s, n, r);
  };
}
function ge(r) {
  return new Promise((t) => {
    setTimeout(t, r);
  });
}
class we {
  constructor(t) {
    o(this, "ee", new w());
    o(this, "state");
    o(this, "botInline");
    o(this, "postEvent");
    o(this, "createRequestId");
    o(this, "requestingPhoneAccess", !1);
    o(this, "requestingWriteAccess", !1);
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    /**
     * Checks if specified method parameter is supported by current component.
     */
    o(this, "supportsParam");
    const {
      postEvent: e = d,
      headerColor: s,
      backgroundColor: n,
      version: i,
      botInline: a,
      createRequestId: c
    } = t, u = C(i, {
      requestPhoneAccess: "web_app_request_phone",
      requestWriteAccess: "web_app_request_write_access",
      switchInlineQuery: "web_app_switch_inline_query",
      setHeaderColor: "web_app_set_header_color",
      setBackgroundColor: "web_app_set_background_color"
    });
    this.postEvent = e, this.botInline = a, this.createRequestId = c, this.supports = (p) => !(!u(p) || p === "switchInlineQuery" && !a), this.state = new m({ backgroundColor: n, headerColor: s }, this.ee), this.supportsParam = Et(i, {
      "setHeaderColor.color": ["web_app_set_header_color", "color"]
    });
  }
  /**
   * Attempts to get requested contact.
   */
  async getRequestedContact() {
    return D(
      "getRequestedContact",
      {},
      this.createRequestId(),
      {
        postEvent: this.postEvent,
        timeout: 1e4
      }
    ).then((t) => fe.parse(t));
  }
  /**
   * The Mini App background color.
   */
  get backgroundColor() {
    return this.state.get("backgroundColor");
  }
  /**
   * Closes the Mini App.
   */
  close() {
    this.postEvent("web_app_close");
  }
  /**
   * The Mini App header color. Could either be a header color key or RGB color.
   */
  get headerColor() {
    return this.state.get("headerColor");
  }
  /**
   * True if Mini App is currently launched in bot inline mode.
   */
  get isBotInline() {
    return this.botInline;
  }
  /**
   * True if current Mini App background color recognized as dark.
   */
  get isDark() {
    return bt(this.backgroundColor);
  }
  /**
   * True if phone access is currently being requested.
   */
  get isRequestingPhoneAccess() {
    return this.requestingPhoneAccess;
  }
  /**
   * True if write access is currently being requested.
   */
  get isRequestingWriteAccess() {
    return this.requestingWriteAccess;
  }
  /**
   * Informs the Telegram app that the Mini App is ready to be displayed.
   *
   * It is recommended to call this method as early as possible, as soon as all essential
   * interface elements loaded. Once this method called, the loading placeholder is hidden
   * and the Mini App shown.
   *
   * If the method not called, the placeholder will be hidden only when the page fully loaded.
   */
  ready() {
    this.postEvent("web_app_ready");
  }
  /**
   * Requests current user contact information. In contrary to requestPhoneAccess, this method
   * returns promise with contact information that rejects in case, user denied access, or request
   * failed.
   * @param options - additional options.
   */
  async requestContact({ timeout: t = 5e3 } = {}) {
    try {
      return await this.getRequestedContact();
    } catch {
    }
    if (await this.requestPhoneAccess() !== "sent")
      throw new Error("Access denied.");
    const s = Date.now() + t;
    let n = 50;
    return wt(async () => {
      for (; Date.now() < s; ) {
        try {
          return await this.getRequestedContact();
        } catch {
        }
        await ge(n), n += 50;
      }
      throw new Error("Unable to retrieve requested contact.");
    }, t);
  }
  /**
   * Requests current user phone access. Method returns promise, which resolves
   * status of the request. In case, user accepted the request, Mini App bot will receive
   * the according notification.
   *
   * To obtain the retrieved information instead, utilize the requestContact method.
   * @param options - additional options.
   * @see requestContact
   */
  requestPhoneAccess(t = {}) {
    if (this.requestingPhoneAccess)
      throw new Error("Phone access is already being requested.");
    return this.requestingPhoneAccess = !0, y("web_app_request_phone", "phone_requested", {
      ...t,
      postEvent: this.postEvent
    }).then((e) => e.status).finally(() => {
      this.requestingPhoneAccess = !1;
    });
  }
  /**
   * Requests write message access to current user.
   * @param options - additional options.
   */
  requestWriteAccess(t = {}) {
    if (this.requestingWriteAccess)
      throw new Error("Write access is already being requested.");
    return this.requestingWriteAccess = !0, y("web_app_request_write_access", "write_access_requested", {
      ...t,
      postEvent: this.postEvent
    }).then((e) => e.status).finally(() => {
      this.requestingWriteAccess = !1;
    });
  }
  /**
   * A method used to send data to the bot. When this method called, a service message sent to
   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the
   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).
   *
   * This method is only available for Mini Apps launched via a Keyboard button.
   * @param data - data to send to bot.
   * @throws {Error} data has incorrect size.
   */
  sendData(t) {
    const { size: e } = new Blob([t]);
    if (e === 0 || e > 4096)
      throw new Error(`Passed data has incorrect size: ${e}`);
    this.postEvent("web_app_data_send", { data: t });
  }
  /**
   * Updates current Mini App header color.
   * @param color - color key or RGB color.
   */
  setHeaderColor(t) {
    this.postEvent("web_app_set_header_color", tt(t) ? { color: t } : { color_key: t }), this.state.set("headerColor", t);
  }
  /**
   * Updates current Mini App background color.
   * @param color - RGB color.
   */
  setBackgroundColor(t) {
    this.postEvent("web_app_set_background_color", { color: t }), this.state.set("backgroundColor", t);
  }
  /**
   * Inserts the bot's username and the specified inline query in the current chat's input field.
   * Query may be empty, in which case only the bot's username will be inserted. The client prompts
   * the user to choose a specific chat, then opens that chat and inserts the bot's username and
   * the specified inline query in the input field.
   * @param text - text which should be inserted in the input after the current bot name. Max
   * length is 256 symbols.
   * @param chatTypes - List of chat types which could be chosen to send the message. Could be
   * empty list.
   */
  switchInlineQuery(t, e = []) {
    if (!this.supports("switchInlineQuery") && !this.isBotInline)
      throw new Error("Method is unsupported because Mini App should be launched in inline mode.");
    this.postEvent("web_app_switch_inline_query", {
      query: t,
      chat_types: e
    });
  }
}
function _e(r) {
  const t = r.message.trim(), e = (r.title || "").trim(), s = r.buttons || [];
  let n;
  if (e.length > 64)
    throw new Error(`Title has incorrect size: ${e.length}`);
  if (t.length === 0 || t.length > 256)
    throw new Error(`Message has incorrect size: ${t.length}`);
  if (s.length > 3)
    throw new Error(`Buttons have incorrect size: ${s.length}`);
  return s.length === 0 ? n = [{ type: "close", id: "" }] : n = s.map((i) => {
    const { id: a = "" } = i;
    if (a.length > 64)
      throw new Error(`Button ID has incorrect size: ${a}`);
    if (i.type === void 0 || i.type === "default" || i.type === "destructive") {
      const c = i.text.trim();
      if (c.length === 0 || c.length > 64) {
        const u = i.type || "default";
        throw new Error(`Button text with type "${u}" has incorrect size: ${i.text.length}`);
      }
      return { ...i, text: c, id: a };
    }
    return { ...i, id: a };
  }), { title: e, message: t, buttons: n };
}
class be {
  constructor(t, e = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = e, this.state = new m({ isOpened: !1 }, this.ee), this.supports = C(t, { open: "web_app_open_popup" });
  }
  set isOpened(t) {
    this.state.set("isOpened", t);
  }
  /**
   * True if popup is currently opened.
   */
  get isOpened() {
    return this.state.get("isOpened");
  }
  /**
   * A method that shows a native popup described by the `params` argument.
   * Promise will be resolved when popup is closed. Resolved value will have
   * an identifier of pressed button.
   *
   * In case, user clicked outside the popup or clicked top right popup close
   * button, null will be returned.
   *
   * FIXME: In desktop, this function may work incorrectly.
   *  Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/7
   * @param options - popup parameters.
   * @throws {Error} Popup is already opened.
   */
  open(t) {
    if (this.isOpened)
      throw new Error("Popup is already opened.");
    return this.isOpened = !0, y("web_app_open_popup", "popup_closed", {
      postEvent: this.postEvent,
      params: _e(t)
    }).then(({ button_id: e = null }) => e).finally(() => {
      this.isOpened = !1;
    });
  }
}
class me {
  constructor(t, e = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = e, this.state = new m({ isOpened: !1 }, this.ee), this.supports = C(t, {
      close: "web_app_close_scan_qr_popup",
      open: "web_app_open_scan_qr_popup"
    });
  }
  /**
   * Closes scanner.
   */
  close() {
    this.postEvent("web_app_close_scan_qr_popup"), this.isOpened = !1;
  }
  set isOpened(t) {
    this.state.set("isOpened", t);
  }
  /**
   * Returns true in case, QR scanner is currently opened.
   */
  get isOpened() {
    return this.state.get("isOpened");
  }
  /**
   * Opens scanner with specified title shown to user. Method returns promise
   * with scanned QR content in case, it was scanned. It will contain null in
   * case, scanner was closed.
   * @param text - title to display.
   */
  async open(t) {
    if (this.isOpened)
      throw new Error("QR scanner is already opened.");
    this.isOpened = !0;
    try {
      const e = await y(
        "web_app_open_scan_qr_popup",
        ["qr_text_received", "scan_qr_popup_closed"],
        {
          postEvent: this.postEvent,
          params: { text: t }
        }
      );
      return typeof e == "object" && typeof e.data == "string" ? e.data : null;
    } finally {
      this.isOpened = !1;
    }
  }
}
class ye {
  constructor(t, e, s = d) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "on", (t, e) => t === "click" ? E("settings_button_pressed", e) : this.ee.on(t, e));
    /**
     * Removes event listener.
     * @param event - event name.
     * @param listener - event listener.
     */
    o(this, "off", (t, e) => t === "click" ? I("settings_button_pressed", e) : this.ee.off(t, e));
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    this.postEvent = s, this.state = new m({ isVisible: t }, this.ee), this.supports = C(e, {
      show: "web_app_setup_settings_button",
      hide: "web_app_setup_settings_button"
    });
  }
  set isVisible(t) {
    this.state.set("isVisible", t), this.postEvent("web_app_setup_settings_button", { is_visible: t });
  }
  /**
   * True if SettingsButton is currently visible.
   */
  get isVisible() {
    return this.state.get("isVisible");
  }
  /**
   * Hides the SettingsButton.
   */
  hide() {
    this.isVisible = !1;
  }
  /**
   * Shows the SettingsButton.
   */
  show() {
    this.isVisible = !0;
  }
}
function Ee(r) {
  return r.replace(/(^|_)bg/, (t, e) => `${e}background`).replace(/_([a-z])/g, (t, e) => e.toUpperCase());
}
function Ce(r) {
  return r.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`).replace(/(^|_)background/, (t, e) => `${e}bg`);
}
const Ct = R(
  (r) => {
    const t = gt().optional();
    return Object.entries(X(r)).reduce((e, [s, n]) => (e[Ee(s)] = t.parse(n), e), {});
  },
  "ThemeParams"
);
function vt(r) {
  return Ct().parse(r);
}
function er(r) {
  return y("web_app_request_theme", "theme_changed", r).then(vt);
}
function ve(r) {
  return JSON.stringify(
    Object.entries(r).reduce((t, [e, s]) => (s && (t[Ce(e)] = s), t), {})
  );
}
class Pe {
  constructor(t) {
    o(this, "ee", new w());
    o(this, "state");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    this.state = new m(t, this.ee);
  }
  /**
   * @since v6.10
   */
  get accentTextColor() {
    return this.get("accentTextColor");
  }
  get backgroundColor() {
    return this.get("backgroundColor");
  }
  get buttonColor() {
    return this.get("buttonColor");
  }
  get buttonTextColor() {
    return this.get("buttonTextColor");
  }
  get destructiveTextColor() {
    return this.get("destructiveTextColor");
  }
  /**
   * Retrieves palette color value by its name.
   * @param key - palette key name.
   */
  get(t) {
    return this.state.get(t);
  }
  /**
   * Returns the copy of the internal state of the current component instance.
   */
  getState() {
    return this.state.clone();
  }
  /**
   * @since v6.10
   */
  get headerBackgroundColor() {
    return this.get("headerBackgroundColor");
  }
  get hintColor() {
    return this.get("hintColor");
  }
  /**
   * Returns true in case, current color scheme is recognized as dark. This
   * value is calculated according to theme background color.
   */
  get isDark() {
    return !this.backgroundColor || bt(this.backgroundColor);
  }
  get linkColor() {
    return this.get("linkColor");
  }
  get secondaryBackgroundColor() {
    return this.get("secondaryBackgroundColor");
  }
  /**
   * @since v6.10
   */
  get sectionBackgroundColor() {
    return this.get("sectionBackgroundColor");
  }
  /**
   * @since v6.10
   */
  get sectionHeaderTextColor() {
    return this.get("sectionHeaderTextColor");
  }
  /**
   * Starts listening to theme changes and applies them.
   * @returns Function to stop listening.
   */
  listen() {
    return E("theme_changed", (t) => {
      this.state.set(vt(t.theme_params));
    });
  }
  /**
   * @since v6.10
   */
  get subtitleTextColor() {
    return this.get("subtitleTextColor");
  }
  get textColor() {
    return this.get("textColor");
  }
}
class Se {
  constructor(t, e, s = d) {
    /**
     * Checks if specified method is supported by current component.
     */
    o(this, "supports");
    /**
     * Checks if specified method parameter is supported by current component.
     */
    o(this, "supportsParam");
    this.version = t, this.createRequestId = e, this.postEvent = s, this.supports = C(t, {
      readTextFromClipboard: "web_app_read_text_from_clipboard"
    }), this.supportsParam = Et(t, {
      "openLink.tryInstantView": ["web_app_open_link", "try_instant_view"]
    });
  }
  /**
   * Opens a link in an external browser. The Mini App will not be closed.
   *
   * Note that this method can be called only in response to the user
   * interaction with the Mini App interface (e.g. click inside the Mini App
   * or on the main button).
   * @param url - URL to be opened.
   * @param tryInstantView
   */
  openLink(t, e) {
    const s = new URL(t, window.location.href).toString();
    if (!A("web_app_open_link", this.version)) {
      window.open(s, "_blank");
      return;
    }
    this.postEvent("web_app_open_link", {
      url: s,
      ...typeof e == "boolean" ? { try_instant_view: e } : {}
    });
  }
  /**
   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing
   * link in full format, with hostname "t.me".
   * @param url - URL to be opened.
   * @throws {Error} URL has not allowed hostname.
   */
  openTelegramLink(t) {
    const {
      hostname: e,
      pathname: s,
      search: n
    } = new URL(t, window.location.href);
    if (e !== "t.me")
      throw new Error(`URL has not allowed hostname: ${e}. Only "t.me" is allowed`);
    if (!A("web_app_open_tg_link", this.version)) {
      window.location.href = t;
      return;
    }
    this.postEvent("web_app_open_tg_link", { path_full: s + n });
  }
  /**
   * Reads text from clipboard and returns string or null. null is returned
   * in cases:
   * - Value in clipboard is not text
   * - Access to clipboard is not allowed
   */
  async readTextFromClipboard() {
    const t = this.createRequestId(), {
      data: e = null
    } = await y("web_app_read_text_from_clipboard", "clipboard_text_received", {
      postEvent: this.postEvent,
      params: { req_id: t },
      capture: lt(t)
    });
    return e;
  }
}
function ke(r) {
  return ["macos", "tdesktop", "unigram", "web", "weba"].includes(r);
}
async function Pt(r) {
  const t = await y("web_app_request_viewport", "viewport_changed", r);
  return {
    height: t.height,
    width: t.width,
    isExpanded: t.is_expanded,
    isStateStable: t.is_state_stable
  };
}
function L(r) {
  return r < 0 ? 0 : r;
}
class xe {
  constructor(t) {
    o(this, "ee", new w());
    o(this, "state");
    o(this, "postEvent");
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
    const {
      height: e,
      isExpanded: s,
      width: n,
      stableHeight: i,
      postEvent: a = d
    } = t;
    this.postEvent = a, this.state = new m({
      height: L(e),
      isExpanded: s,
      stableHeight: L(i),
      width: L(n)
    }, this.ee);
  }
  /**
   * Request viewport information from the Telegram application and updates current Viewport
   * instance.
   * @param options - options to request fresh data.
   */
  sync(t) {
    return Pt(t).then(({ height: e, isExpanded: s, width: n, isStateStable: i }) => {
      this.state.set({
        height: e,
        width: n,
        isExpanded: s,
        stableHeight: i ? e : this.state.get("stableHeight")
      });
    });
  }
  /**
   * The current height of the visible area of the Mini App.
   *
   * The application can display just the top part of the Mini App, with its
   * lower part remaining outside the screen area. From this position, the
   * user can "pull" the Mini App to its maximum height, while the bot can do
   * the same by calling `expand` method. As the position of the Mini App
   * changes, the current height value of the visible area will be updated
   * in real time.
   *
   * Please note that the refresh rate of this value is not sufficient
   * to smoothly follow the lower border of the window. It should not be
   * used to pin interface elements to the bottom of the visible area. It's
   * more appropriate to use the value of the `stableHeight`
   * field for this purpose.
   */
  get height() {
    return this.state.get("height");
  }
  /**
   * The height of the visible area of the Mini App in its last stable state.
   *
   * The application can display just the top part of the Mini App, with its
   * lower part remaining outside the screen area. From this position,
   * the user can "pull" the Mini App to its maximum height, while the bot can
   * do the same by calling `expand` method.
   *
   * Unlike the value of `height`, the value of `stableHeight`
   * does not change as the position of the Mini App changes with user
   * gestures or during animations. The value of `stableHeight`
   * will be updated after all gestures and animations are completed and
   * the Mini App reaches its final size.
   */
  get stableHeight() {
    return this.state.get("stableHeight");
  }
  /**
   * Starts listening to viewport changes and applies them.
   * @returns Function to stop listening.
   */
  listen() {
    return E("viewport_changed", (t) => {
      const {
        height: e,
        width: s,
        is_expanded: n,
        is_state_stable: i
      } = t, a = {
        height: L(e),
        isExpanded: n,
        width: L(s)
      };
      i && (a.stableHeight = a.height), this.state.set(a);
    });
  }
  /**
   * Returns true if the Mini App is expanded to the maximum available height.
   * Otherwise, if the Mini App occupies part of the screen and can be expanded
   * to the full height using `expand` method.
   * @see expand
   */
  get isExpanded() {
    return this.state.get("isExpanded");
  }
  /**
   * Current viewport width.
   */
  get width() {
    return this.state.get("width");
  }
  /**
   * A method that expands the Mini App to the maximum available height. To
   * find out if the Mini App is expanded to the maximum height, refer to the
   * value of the `isExpanded`.
   * @see isExpanded
   */
  expand() {
    this.postEvent("web_app_expand"), this.state.set("isExpanded", !0);
  }
  /**
   * Returns true in case current viewport height is stable and is not going to
   * change in the next moment.
   */
  get isStable() {
    return this.stableHeight === this.height;
  }
}
function S(r, t) {
  document.documentElement.style.setProperty(r, t);
}
function qe(r, t) {
  const e = () => {
    S("--tg-background-color", r.backgroundColor);
  }, s = () => {
    const {
      backgroundColor: n,
      secondaryBackgroundColor: i
    } = t;
    if (tt(r.headerColor)) {
      S("--tg-header-color", r.headerColor);
      return;
    }
    if (r.headerColor === "bg_color" && n) {
      S("--tg-header-color", n);
      return;
    }
    r.headerColor === "secondary_bg_color" && i && S("--tg-header-color", i);
  };
  t.on("change", s), r.on("change:backgroundColor", e), r.on("change:headerColor", s), e(), s();
}
function Ae(r) {
  const t = () => {
    const e = r.getState();
    Object.entries(e).forEach(([s, n]) => {
      if (n) {
        const i = s.replace(/[A-Z]/g, (a) => `-${a.toLowerCase()}`);
        S(`--tg-theme-${i}`, n);
      }
    });
  };
  r.on("change", t), t();
}
function ot(r) {
  const t = () => S("--tg-viewport-height", `${r.height}px`), e = () => S("--tg-viewport-width", `${r.width}px`), s = () => S("--tg-viewport-stable-height", `${r.stableHeight}px`);
  r.on("change:height", t), r.on("change:width", e), r.on("change:stableHeight", s), t(), e(), s();
}
function Ve() {
  const r = document.createElement("style");
  r.id = "telegram-custom-styles", document.head.appendChild(r), E("set_custom_style", (t) => {
    r.innerHTML = t;
  });
}
function St(r) {
  return `telegram-mini-apps-${r}`;
}
function T(r, t) {
  sessionStorage.setItem(St(r), JSON.stringify(t));
}
function $(r) {
  const t = sessionStorage.getItem(St(r));
  return t ? JSON.parse(t) : null;
}
function Re(r, t, e) {
  const { isVisible: s = !1 } = r ? $("back-button") || {} : {}, n = new re(s, t, e);
  return n.on("change", () => {
    T("back-button", { isVisible: n.isVisible });
  }), n;
}
function Ie(r, t) {
  const { isConfirmationNeeded: e = !1 } = r ? $("closing-behavior") || {} : {}, s = new se(e, t);
  return s.on("change", () => T("closing-behavior", {
    isConfirmationNeeded: s.isConfirmationNeeded
  })), s;
}
function Te(r, t, e, s) {
  const {
    backgroundColor: n = t,
    isEnabled: i = !1,
    isVisible: a = !1,
    isLoaderVisible: c = !1,
    textColor: u = e,
    text: p = ""
  } = r ? $("main-button") || {} : {}, g = new de({
    backgroundColor: n,
    isEnabled: i,
    isLoaderVisible: c,
    isVisible: a,
    postEvent: s,
    text: p,
    textColor: u
  }), _ = () => T("main-button", {
    backgroundColor: g.backgroundColor,
    isEnabled: g.isEnabled,
    isLoaderVisible: g.isLoaderVisible,
    isVisible: g.isVisible,
    text: g.text,
    textColor: g.textColor
  });
  return g.on("change", _), g;
}
function $e(r, t, e, s, n, i) {
  const {
    backgroundColor: a = t,
    headerColor: c = "bg_color"
  } = r ? $("mini-app") || {} : {}, u = new we({
    headerColor: c,
    backgroundColor: a,
    version: e,
    botInline: s,
    createRequestId: n,
    postEvent: i
  }), p = () => T("mini-app", {
    backgroundColor: u.backgroundColor,
    headerColor: u.headerColor
  });
  return u.on("change", p), u;
}
function Le() {
  let r = 0;
  return () => (r += 1, r.toString());
}
function Be(r, t, e) {
  const { isVisible: s = !1 } = r ? $("settings-button") || {} : {}, n = new ye(s, t, e);
  return n.on("change", () => {
    T("settings-button", { isVisible: n.isVisible });
  }), n;
}
function De(r) {
  const t = new Pe(r);
  return t.listen(), t;
}
function M(r) {
  const t = new xe(r);
  return t.on("change", () => T("viewport", {
    height: t.height,
    isExpanded: t.isExpanded,
    stableHeight: t.stableHeight,
    width: t.width
  })), t.listen(), t;
}
function Oe(r, t, e, s) {
  const n = r ? $("viewport") : null;
  if (n)
    return M({ ...n, postEvent: e });
  if (ke(t))
    return M({
      height: window.innerHeight,
      isExpanded: !0,
      postEvent: e,
      stableHeight: window.innerHeight,
      width: window.innerWidth
    });
  if (s)
    return Pt({
      postEvent: e,
      timeout: 5e3
    }).then(({ height: a, isStateStable: c, ...u }) => M({
      ...u,
      height: a,
      stableHeight: c ? a : 0
    }));
  const i = M({
    width: 0,
    height: 0,
    isExpanded: !1,
    postEvent: e,
    stableHeight: 0
  });
  return i.sync({ postEvent: e, timeout: 5e3 }).catch((a) => {
    console.error("Unable to actualize viewport state", a);
  }), i;
}
function We(r) {
  return typeof r == "object" ? r : r ? {
    themeParams: !0,
    viewport: !0,
    miniApp: !0
  } : {};
}
function at(r, t, e, s) {
  const n = We(r);
  n.miniApp && qe(t, e), n.themeParams && Ae(e), n.viewport && (s instanceof Promise ? s.then(ot) : ot(s));
}
function He() {
  return et({
    botInline: {
      type: P().optional(),
      from: "tgWebAppBotInline"
    },
    initData: {
      type: yt().optional(),
      from: "tgWebAppData"
    },
    initDataRaw: {
      type: h().optional(),
      from: "tgWebAppData"
    },
    platform: {
      type: h(),
      from: "tgWebAppPlatform"
    },
    showSettings: {
      type: P().optional(),
      from: "tgWebAppShowSettings"
    },
    startParam: {
      type: h().optional(),
      from: "tgWebAppStartParam"
    },
    themeParams: {
      type: Ct(),
      from: "tgWebAppThemeParams"
    },
    version: {
      type: h(),
      from: "tgWebAppVersion"
    }
  }, "LaunchParams");
}
function kt(r) {
  return He().parse(r);
}
function xt(r) {
  return kt(
    r.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function Ne() {
  return xt(window.location.href);
}
function qt() {
  return performance.getEntriesByType("navigation")[0];
}
function Ue() {
  const r = qt();
  if (!r)
    throw new Error("Unable to get first navigation entry.");
  return xt(r.name);
}
function Me(r) {
  const {
    initDataRaw: t,
    themeParams: e,
    platform: s,
    version: n,
    showSettings: i,
    startParam: a,
    botInline: c
  } = r, u = new URLSearchParams();
  return t && u.set("tgWebAppData", t), u.set("tgWebAppPlatform", s), u.set("tgWebAppThemeParams", ve(e)), u.set("tgWebAppVersion", n), a && u.set("tgWebAppStartParam", a), typeof i == "boolean" && u.set("tgWebAppShowSettings", i ? "1" : "0"), typeof c == "boolean" && u.set("tgWebAppBotInline", c ? "1" : "0"), u.toString();
}
const At = "telegram-mini-apps-launch-params";
function Ge() {
  return kt(sessionStorage.getItem(At) || "");
}
function je(r) {
  sessionStorage.setItem(At, Me(r));
}
function rt() {
  const r = [];
  for (const t of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed and then page was reloaded.
    Ne,
    // Then, try using the lower level API - window.performance.
    Ue,
    // Finally, try to extract launch parameters from the session storage.
    Ge
  ])
    try {
      const e = t();
      return je(e), e;
    } catch (e) {
      r.push(e);
    }
  throw k.error("Unable to extract launch parameters. Received errors:", r), new Error("Unable to retrieve launch parameters from any known source.");
}
function Vt() {
  var r;
  return ((r = qt()) == null ? void 0 : r.type) === "reload";
}
function rr(r = {}) {
  const {
    async: t = !1,
    complete: e = t,
    cssVars: s = !1,
    acceptCustomStyles: n = !1
  } = r;
  try {
    const {
      initData: i,
      initDataRaw: a,
      version: c,
      platform: u,
      themeParams: p,
      botInline: g = !1
    } = rt(), _ = Vt(), b = Le(), l = Ot(c);
    pt() && (n && Ve(), l("iframe_ready", { reload_supported: !0 }), E("reload_iframe", () => {
      l("iframe_will_reload"), window.location.reload();
    }));
    const q = {
      backButton: Re(_, c, l),
      closingBehavior: Ie(_, l),
      cloudStorage: new ae(c, b, l),
      createRequestId: b,
      hapticFeedback: new ce(c, l),
      invoice: new le(c, l),
      mainButton: Te(
        _,
        p.buttonColor || "#000000",
        p.buttonTextColor || "#ffffff",
        l
      ),
      miniApp: $e(
        _,
        p.backgroundColor || "#ffffff",
        c,
        g,
        b,
        l
      ),
      popup: new be(c, l),
      postEvent: l,
      qrScanner: new me(c, l),
      settingsButton: Be(_, c, l),
      themeParams: De(p),
      utils: new Se(c, b, l),
      ...i ? {
        initData: new ue(i),
        initDataRaw: a
      } : {}
    }, N = Oe(_, u, l, e);
    return N instanceof Promise || e ? Promise.resolve(N).then((st) => (at(
      s,
      q.miniApp,
      q.themeParams,
      st
    ), { ...q, viewport: st })) : (at(
      s,
      q.miniApp,
      q.themeParams,
      N
    ), { ...q, viewport: N });
  } catch (i) {
    if (e)
      return Promise.reject(i);
    throw i;
  }
}
function sr() {
  return {
    launchParams: rt(),
    isPageReload: Vt()
  };
}
function nr() {
  try {
    return rt(), !0;
  } catch {
    return !1;
  }
}
function ir(r) {
  const t = r.match(/#(.+)/);
  return t ? t[1] : null;
}
async function O(r) {
  return r === 0 ? !0 : Promise.race([
    new Promise((t) => {
      window.addEventListener("popstate", function e() {
        window.removeEventListener("popstate", e), t(!0);
      }), window.history.go(r);
    }),
    // Usually, it takes about 1ms to emit this event, but we use some buffer.
    new Promise((t) => {
      setTimeout(t, 50, !1);
    })
  ]);
}
async function Fe() {
  if (window.history.length <= 1 || (window.history.pushState(null, ""), await O(1 - window.history.length)))
    return;
  let t = await O(-1);
  for (; t; )
    t = await O(-1);
}
function B(r, t) {
  return r.startsWith(t) ? r : `${t}${r}`;
}
class ze {
  constructor(t, e, {
    debug: s = !1,
    loggerPrefix: n = "Navigator"
  }) {
    o(this, "logger");
    o(this, "entries");
    if (this.entriesCursor = e, t.length === 0)
      throw new Error("Entries list should not be empty.");
    if (e >= t.length)
      throw new Error("Cursor should be less than entries count.");
    this.entries = t.map(({ pathname: i = "", search: a, hash: c }) => {
      if (!i.startsWith("/") && i.length > 0)
        throw new Error('Pathname should start with "/"');
      return {
        pathname: B(i, "/"),
        search: a ? B(a, "?") : "",
        hash: c ? B(c, "#") : ""
      };
    }), this.logger = new ht(`[${n}]`, s);
  }
  /**
   * Converts entry to the navigation entry.
   * @param entry - entry data
   */
  formatEntry(t) {
    let e;
    if (typeof t == "string")
      e = t;
    else {
      const {
        pathname: a = "",
        search: c,
        hash: u
      } = t;
      e = a + (c ? B(c, "?") : "") + (u ? B(u, "#") : "");
    }
    const {
      pathname: s,
      search: n,
      hash: i
    } = new URL(e, `https://localhost${this.path}`);
    return {
      pathname: s,
      search: n,
      hash: i
    };
  }
  /**
   * Current entry.
   */
  get entry() {
    return this.entries[this.entriesCursor];
  }
  /**
   * Goes back in history.
   */
  back() {
    return this.go(-1);
  }
  /**
   * Current entries cursor.
   */
  get cursor() {
    return this.entriesCursor;
  }
  /**
   * True if navigator can go back.
   */
  get canGoBack() {
    return this.entriesCursor > 0;
  }
  /**
   * True if navigator can go forward.
   */
  get canGoForward() {
    return this.entriesCursor !== this.entries.length - 1;
  }
  /**
   * Goes forward in history.
   */
  forward() {
    return this.go(1);
  }
  /**
   * Moves entries cursor by specified delta.
   * @param delta - cursor delta.
   */
  go(t) {
    this.logger.log(`called go(${t})`);
    const e = Math.min(
      this.entries.length - 1,
      Math.max(this.entriesCursor + t, 0)
    );
    if (this.entriesCursor === e)
      return this.performGo({
        updated: !1,
        delta: t
      });
    const s = this.entry;
    this.entriesCursor = e;
    const n = this.entry;
    return this.logger.log("State changed", { before: s, after: n }), this.performGo({
      updated: !0,
      delta: t,
      before: s,
      after: n
    });
  }
  /**
   * Returns copy of navigator entries.
   */
  getEntries() {
    return this.entries.map((t) => ({ ...t }));
  }
  /**
   * Current hash.
   * @example
   * "", "#", "#hash"
   */
  get hash() {
    return this.entry.hash;
  }
  /**
   * Pushes new entry. Method replaces all entries after the current one with the inserted.
   * @param entry - entry data.
   *
   * @example Pushing absolute pathname.
   * push("/absolute-path"); // "/absolute-path"
   *
   * @example Pushing relative pathname.
   * // Pushing relative path replaces N last path parts, where N is pushed pathname parts count.
   * // Pushing empty path is recognized as relative, but not replacing the last pathname part.
   * push("relative"); // "/home/root" -> "/home/relative"
   *
   * @example Pushing query parameters.
   * push("/absolute?my-param=1"); // "/home" -> "/absolute?my-param=1"
   * push("relative?my-param=1"); // "/home/root" -> "/home/relative?my-param=1"
   * push("?my-param=1"); // "/home" -> "/home?my-param=1"
   *
   * @example Pushing hash.
   * push("#my-hash"); // "/home" -> "/home#my-hash"
   * push("johny#my-hash"); // "/home/root" -> "/home/johny#my-hash"
   */
  push(t) {
    this.entriesCursor !== this.entries.length - 1 && this.entries.splice(this.entriesCursor + 1);
    const e = this.formatEntry(t), s = this.entry;
    this.entriesCursor += 1, this.entries[this.entriesCursor] = e;
    const n = this.entry;
    return this.logger.log("State changed", { before: s, after: n }), this.performPush({
      before: s,
      after: n
    });
  }
  /**
   * Current full path including pathname, query parameters and hash.
   */
  get path() {
    return `${this.pathname}${this.search}${this.hash}`;
  }
  /**
   * Current pathname.
   * @example
   * "/", "/abc"
   */
  get pathname() {
    return this.entry.pathname;
  }
  /**
   * Replaces current entry. Has the same logic as `push` method.
   * @param entry - entry data.
   * @see push
   * @returns True if changes were done.
   */
  replace(t) {
    const e = this.formatEntry(t);
    if (this.search === e.search && this.pathname === e.pathname && this.hash === e.hash)
      return this.performReplace({
        updated: !1,
        entry: e
      });
    const s = this.entry;
    this.entries[this.entriesCursor] = e;
    const n = this.entry;
    return this.logger.log("State changed", { before: s, after: n }), this.performReplace({
      updated: !0,
      before: s,
      after: n
    });
  }
  /**
   * Current query parameters.
   * @example
   * "", "?", "?a=1"
   */
  get search() {
    return this.entry.search;
  }
}
const ct = 0, Q = 1, Z = 2;
class Rt extends ze {
  constructor(e, s, n = {}) {
    super(e, s, {
      ...n,
      loggerPrefix: "HashNavigator"
    });
    o(this, "ee", new w());
    o(this, "attached", !1);
    /**
     * Handles window "popstate" event.
     * @param state - event state.
     */
    o(this, "onPopState", async ({ state: e }) => {
      if (this.logger.log('"popstate" event received. State:', e), e === null)
        return this.push(window.location.hash.slice(1));
      if (e === ct) {
        this.logger.log("Void reached. Moving history forward"), window.history.forward();
        return;
      }
      if (e === Q)
        return this.back();
      if (e === Z)
        return this.forward();
    });
    o(this, "back", () => super.back());
    /**
     * Adds new event listener.
     */
    o(this, "on", this.ee.on.bind(this.ee));
    /**
     * Removes event listener.
     */
    o(this, "off", this.ee.off.bind(this.ee));
  }
  /**
   * Creates navigator from current window location hash.
   * @param options - options passed to constructor.
   */
  static fromLocation(e) {
    const {
      search: s,
      pathname: n,
      hash: i
    } = new URL(
      window.location.hash.slice(1),
      window.location.href
    );
    return new Rt([{ search: s, pathname: n, hash: i }], 0, e);
  }
  async performGo(e) {
    e.updated && (this.attached && await this.syncHistory(), this.emitChanged(e.before, e.after));
  }
  async performPush({ before: e, after: s }) {
    this.attached && await this.syncHistory(), this.emitChanged(e, s);
  }
  async performReplace(e) {
    e.updated && (this.attached && window.history.replaceState(null, "", `#${this.path}`), this.emitChanged(e.before, e.after));
  }
  /**
   * Synchronizes current navigator state with browser history.
   */
  async syncHistory() {
    window.removeEventListener("popstate", this.onPopState);
    const e = `#${this.path}`;
    await Fe(), d("web_app_setup_back_button", { is_visible: this.canGoBack }), this.canGoBack && this.canGoForward ? (this.logger.log("Setting up history: [<-, *, ->]"), window.history.replaceState(Q, ""), window.history.pushState(null, "", e), window.history.pushState(Z, ""), await O(-1)) : this.canGoBack ? (this.logger.log("Setting up history: [<-, *]"), window.history.replaceState(Q, ""), window.history.pushState(null, "", e)) : this.canGoForward ? (this.logger.log("Setting up history: [*, ->]"), window.history.replaceState(null, e), window.history.pushState(Z, ""), await O(-1)) : (this.logger.log("Setting up history: [~, *]"), window.history.replaceState(ct, ""), window.history.pushState(null, "", e)), window.addEventListener("popstate", this.onPopState);
  }
  emitChanged(e, s) {
    this.ee.emit("change", {
      navigator: this,
      from: e,
      to: s
    });
  }
  /**
   * Attaches current navigator to the browser history allowing navigator to manipulate it.
   */
  async attach() {
    if (!this.attached)
      return this.logger.log("Attaching", this), this.attached = !0, E("back_button_pressed", this.back), this.syncHistory();
  }
  /**
   * Detaches current navigator from the browser history.
   */
  detach() {
    this.attached && (this.logger.log("Detaching", this), this.attached = !1, window.removeEventListener("popstate", this.onPopState), I("back_button_pressed", this.back));
  }
}
function or(r) {
  return r instanceof z;
}
export {
  re as BackButton,
  se as ClosingBehavior,
  ae as CloudStorage,
  ce as HapticFeedback,
  Rt as HashNavigator,
  ue as InitData,
  le as Invoice,
  de as MainButton,
  K as MethodUnsupportedError,
  we as MiniApp,
  ze as Navigator,
  Y as ParameterUnsupportedError,
  j as ParseError,
  G as ParseSchemaFieldError,
  be as Popup,
  me as QRScanner,
  ye as SettingsButton,
  Pe as ThemeParams,
  z as TimeoutError,
  Se as Utils,
  xe as Viewport,
  oe as array,
  qe as bindMiniAppCSSVars,
  Ae as bindThemeCSSVars,
  ot as bindViewportCSSVars,
  P as boolean,
  he as chatParser,
  _t as classNames,
  Dt as compareVersions,
  Ot as createPostEvent,
  mt as date,
  ir as getHash,
  rr as init,
  yt as initDataParser,
  D as invokeCustomMethod,
  bt as isColorDark,
  pt as isIframe,
  Vt as isPageReload,
  tt as isRGB,
  Qt as isRGBShort,
  W as isRecord,
  ke as isStableViewportPlatform,
  nr as isTMA,
  or as isTimeoutError,
  f as json,
  He as launchParamsParser,
  Xe as mergeClassNames,
  x as number,
  I as off,
  E as on,
  Ke as once,
  tr as parseInitData,
  kt as parseLaunchParams,
  Wt as parseMessage,
  vt as parseThemeParams,
  d as postEvent,
  y as request,
  er as requestThemeParams,
  Pt as requestViewport,
  sr as retrieveLaunchData,
  rt as retrieveLaunchParams,
  gt as rgb,
  et as searchParams,
  Me as serializeLaunchParams,
  ve as serializeThemeParams,
  S as setCSSVar,
  Qe as setDebug,
  Ze as setTargetOrigin,
  h as string,
  Ye as subscribe,
  A as supports,
  Ct as themeParamsParser,
  ft as toRGB,
  ee as unsubscribe,
  it as userParser,
  wt as withTimeout
};
